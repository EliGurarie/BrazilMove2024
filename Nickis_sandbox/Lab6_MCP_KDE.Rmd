---
title: 'L4: Home Range Analyses'
author: "Nicole Barbour"
date: "2024-05-15"
output:
  html_document:
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)

knitr::opts_knit$set(root.dir = "C:/Users/nicol/Documents/BrazilMove2024")

```

# Load Data In

We will use the processed elk data from lab 1. 

```{r}
load("./data/elk_processed.rda")
```


# Subset for 3 "Residential" Individuals

We will use the "dplyr" package to select 3 individuals with clear residential behavior from our data.

```{r}
library(dplyr)
```


```{r}
elk_res <- elk_processed |>
  filter(id %in% c("YL80", "YL91", "YL94"))
```

# Visualize Tracks

Let's start off by visualizing our selected tracks, using some of the methods we learned in lab 1.  

We can see that these tracks have a nice "blob" of movement, indicating residential behavior suitable for home range analysis. 

```{r}
library(ggplot2)
```


```{r fig.height=10, fig.width=5}
ggplot(data=elk_res, aes(x=lon, y=lat)) +
  geom_path(size=0.5) +
  theme_classic() +
  facet_wrap(~id, scale="free", ncol=1)
```

# Prep Data for Analysis

We will go through a few steps to prep our data for our home range analyses. 

## Make Data Spatial 

The next step is to make our data spatial, using the methods we learned in lab 1. 

```{r}
library(sf)
```


```{r}
elk_res_sf <- elk_res |> 
  st_as_sf(coords = c("lon","lat"), crs=4326) |>
  st_transform(32611)
```

## Make an Interactive Map of Tracks

We can use the mapview package to make interactive maps of our movement tracks, using the methods we learned in lab 1.

This interactive map is useful for visualizing the tracks on the landscape and with respect to each other. We can see that the tracks overlap with each other quite a bit.

```{r}
library(mapview)
```

```{r}
elk_tracks <- elk_res_sf |> 
  group_by(id) |> 
  summarize(do_union=FALSE) |> 
  st_cast("LINESTRING")

mapview(elk_tracks,zcol="id")
```

## Convert Data to a List

For use with our homerange functions, we will convert our sf object into a list structure, splitting our data by individual.

```{r}
elk_id <- split(elk_res_sf, elk_res_sf$id)
```


# MCP

We will start with applying the Minimum Convex Polygon (MCP) method. For this we will need the "adehabitatHR" package, which has many useful functions for homerange analysis. 

The MCP method is very simple - essentially, it draws the smallest/tightest polygon around the locations, by 1) calculating the centroid of all the points, 2) calculating the distance from each location/point to this centroid, 3) removing all points that have a distance greater than a specified quantile (usually 95-100 percent) and 4) applying the "convex hull" algorithm to determine the minimum convex polygon for the points. 

You can learn more about homerange analysis with this package with the [adehabitat HR vignette](https://cran.r-project.org/web/packages/adehabitatHR/vignettes/adehabitatHR.pdf).

```{r}

library(adehabitatHR)
```

The `mcp` function from adehabitatHR works on one individual at a time. It also requires that the data first be converted to a "SpatialPoints" structure, a different spatial data type (similar to sf, but using the "sp" package instead).

This function also requires that the user specify the quantile to use for selecting locations for the MCP method - generally 95-100%. 

In order to perform our homerange analysis on all of our individuals at once, it will be useful to write a function that takes an individual sf object and a parameter for the percent of points to use for MCP calcuation. The function will return an MCP object, from the `mcp` function. 


```{r}
findMCP <- function(id_sf, percent){
  
  id_sp <- id_sf |> st_cast("POINT") |> as_Spatial()
  
  id_mcp <- mcp(id_sp, percent, unout="km2")
  
  return(id_mcp)
}
```

We can now use the `lapply` function, as we learned in lab 2, to apply our function to each individual in our list object. The output object is a list of the same dimensions, with an MCP object for each individual.

```{r}
elk_mcp <- lapply(elk_id,
                  findMCP,
                  percent=95)
```

We can take a look at the MCP object for one example individual, "YL80".

The object includes the estimated area (in km^2) of the homerange from the MCP method.

```{r}
elk_mcp["YL80"]
```

We can also visualize the resulting MCP's, using the mapview package. Here we can see that there is a quite a bit of overlap between these MCP homeranges.

```{r}
mapview(elk_mcp["YL80"], col.regions="red", map.types="Esri.WorldImagery")+
  mapview(elk_mcp["YL91"], col.regions="orange")+
  mapview(elk_mcp["YL94"], col.regions="blue")
```


# KDE

Kernel density estimation (KDE) is a slightly more complex method used to calculate homerange areas, also using the adehabitatHR package. As defined by this package, it essentially defines the KDE homerange as the "*minimum area in which an animal has some specified probability of being located*".

KDE applies a user-specified function to input points/locations in order to predict the probability of occurrence or the "utilization distribution", within each pixel of a user-specified grid. The choice of resolution for this grid can have a trade-off, with a finer resolution being more memory-intensive to calculate. The choice of this resolution should be informed by the resolution of the input data.

A commonly used function for KDE (and the default for the adehabitatHR package function, `kernelUD`) is the "bivariate normal kernel". This function takes a set of individual observations, a parameter for the number of observations, and *importantly*, a user-specified parameter for the smoothing factor, *h* (also called the "bandwidth"). The choice of the value for this *h* parameter can significantly impact results, with a larger *h* resulting in more smoothing or a larger distance over which a data point influences the utlization distribution. The adehabitatHR package uses the "reference bandwidth" as a default with its `kernelUD` function but additional options exist (e.g., the "least-square cross validation method" or a user-chosen value).

Users can also specify the percentage of density to use for homerange estimation (usually 50-95%), within the `getverticeshr` function, which calculates the homerange area using the estimated utilization distribution from the `kernelUD` function.

Similar to the `mcp` function, the `kernelUD` and `getverticeshr` functions are applied to one individual at a time. To apply to all individuals at once, we can write our own function. The function takes an individual sf object, a user-specified grid, and a user-specified percent. It then converts the data into "SpatialPoints" format and applies the `kernelUD` and `getverticeshr` to get the estimated homerange contour. The contour is then converted back to an sf object (as a POLYGON) and the area of the polygon is calculated using the `st_area`. This area is added as a column to our output homerange polygon object.

```{r}
findKDE <- function(id_sf, grid, percent){
  
  id_sp <- id_sf |> st_cast("POINT") %>% as_Spatial()
  
  id_kernelud <- kernelUD(id_sp, grid = grid)
  
  
  id_homerangecontour <- getverticeshr(id_kernelud, percent)
    
  id_poly <- st_as_sf(id_homerangecontour)
  
  id_poly$area <- st_area(id_poly)
  
  return(id_poly)
}
```

We apply our new `findKDE` function, using a 200 x 200 (pixel, with pixels in units the same as your coordinate reference system, e.g., meters) grid and using 95% for the density estimation cut-off.

```{r}
elk_kde <- lapply(elk_id,
  findKDE,
  grid = 200,
  percent =95
)
```

The output is a list of KDE objects for each individual - we can look at the KDE object, including estimated area, for one of these individuals, "YL80".

```{r}
elk_kde["YL80"]
```

The output KDE objects can also be mapped interactively with mapview! 

How do these KDE homeranges compare to our MCP homeranges?

```{r}
mapview(elk_kde["YL80"], col.regions="red", map.types="Esri.WorldImagery")+
  mapview(elk_kde["YL91"], col.regions="orange")+
  mapview(elk_kde["YL94"], col.regions="blue")
```











