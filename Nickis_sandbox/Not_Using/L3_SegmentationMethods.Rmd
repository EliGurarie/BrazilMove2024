---
title: "L3_ Segmentation Methods"
author: "Nicole Barbour"
date: "2024-05-17"
output:
  html_document:
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)

knitr::opts_knit$set(root.dir = "C:/Users/nicol/Documents/BrazilMove2024")
```

# Load Data In

```{r}
load("./data/elk_processed.rda")
```

# Select Individuals (Non-Residential)

```{r}
library(ggplot2)
```


```{r fig.height=15, fig.width=7}
ggplot(data=elk_processed, aes(x=lon, y=lat)) +
  geom_path(size=0.5, color="darkgrey") +
  theme_classic() +
  facet_wrap(~id, scale="free", ncol=3)
```

```{r}
library(dplyr)
```



```{r}

elk_mig <- elk_processed |>
  filter(id %in% c("GP2", "YL25", "YL29", "YL73", "YL77", "YL78"))

```

```{r}
ggplot(data=elk_mig, aes(x=datetime, y=lat)) +
  geom_path(size=0.5, color="darkgrey") +
  theme_classic() +
  facet_wrap(~id, scale="free", ncol=2)
```
# Data Regularization (AniMotum)

install from my R-universe repository

need latest TMB and Matrix package versions also

```{r eval=FALSE}

install.packages("aniMotum", 
                 repos = c("https://cloud.r-project.org",
                           "https://ianjonsen.r-universe.dev"),
                 dependencies = TRUE)


remotes::install_version('TMB', version = '1.9.10')
install.packages("Matrix")
```


```{r}
library(aniMotum)
```

data should be structured with columns:
id, date (POSIXct), lc, lon, lat and (optional) additional locational error information smaj, smin, eor (Argos tags)

lc (location class) can include the following values: 3, 2, 1, 0, A, B, Z, G, or GL. The latter two are for GPS locations and 'Generic Locations', respectively. Class Z values are assumed to have the same error variances as class B. By default, class G (GPS) locations are assumed to have error variances 10x smaller than Argos class 3 variances, but unlike Argos error variances the GPS variances are the same for longitude and latitude

```{r}
elk_mig2 <- elk_mig |>
  mutate(lc = "G", date = datetime) |>
  dplyr::select(id, date, lc, lon, lat)
```

check sampling rate

```{r}
dtime <- function(t, ...) {difftime(t[-1], t[-length(t)], ...) %>% as.numeric}

sample.rate <- elk_mig2 |> 
  group_by(id) |>
  arrange(date) |>
  mutate(dtime = c(0,round(dtime(date, units ="hours")))) |>
  mutate(mode_dtime = as.numeric(names(sort(table(dtime), decreasing=TRUE))[1])) |>
  data.frame() |>
  ungroup()

barplot(table(sample.rate$dtime))
```

use sample rate of 2 hours

vmax: m/s

time.step: hrs

random walk: better for large data gaps than crw


```{r eval=FALSE}
elk_ssm_fit <- fit_ssm(elk_mig2,
               vmax = 20,
               model = "rw",
               time.step = 2,
               control = ssm_control(verbose = 0))
```

```{r include=FALSE}
#save(elk_ssm_fit, file="./data/elk_ssm_fit.rda")

load("./data/elk_ssm_fit.rda")
```


```{r}
summary(elk_ssm_fit)
```


```{r}

extractPredictions <- function(ssm_fit){
  predictions <- data.frame(ssm_fit$predicted) |>
    sf::st_as_sf() |>
    sf::st_transform(4326)
  
  coords <- sf::st_coordinates(predictions)
  
  predictions$lon <- coords[, 1]
  predictions$lat <- coords[, 2]
  
  new_data <- predictions |> 
    data.frame() |>
    dplyr::select(id, date, lon, lat)
  
  return(new_data)
}

```

```{r}
elk_ssm_list <- elk_ssm_fit$ssm

elk_regdata_list <- lapply(elk_ssm_list,
                      extractPredictions)
```

```{r}
library(ggplot2)
```



```{r}
elk_id <- split(elk_mig2, elk_mig2$id)

track_plots <- c()
for(i in c(1:length(elk_id))){
  track_plots[[i]] <- ggplot()+
    geom_path(data = elk_regdata_list[[i]], aes(x = lon, y = lat), size = 0.7, color = "red")+
    geom_point(data = elk_id[[i]], aes(x = lon, y = lat), size=1, color="black")+
    theme_classic()+
    xlab("Longitude")+ylab("Latitude")+
    facet_wrap(~id,scales="free")
}

track_plots
```

```{r}
elk_regdata <- do.call("rbind", elk_regdata_list)
```


```{r eval= FALSE, include=FALSE}
save(elk_regdata, file="./data/elk_regdata.rda")

```

## Calculate Movement Metrics

```{r}
library(sf)
```


```{r}
elk_reg_utm <- elk_regdata |>
  st_as_sf(coords = c("lon","lat"), crs = 4326) |>
  st_transform(32611)


```

```{r}
coords <- st_coordinates(elk_reg_utm)

elk_regdata$X <- coords[,1]
elk_regdata$Y <- coords[,2]
elk_regdata$Z <- elk_regdata$X + 1i*elk_regdata$Y
```



```{r}
getMovementMetrics <- function(dataframe){
  
  move_step <- diff(dataframe$Z)  

  time_step <- as.numeric(difftime(dataframe$date[-1], dataframe$date[-length(dataframe$date)], "days"))

  absolute_turnangle <- Arg(move_step)

  relative_turnangle <- diff(absolute_turnangle)

  step_length_km <- Mod(move_step)/1000
  
  dataframe$time_step_days <- c(NA, time_step)

  dataframe$step_length_km <- c(NA, step_length_km)

  dataframe$relative_turnangle <- c(NA, NA, relative_turnangle)
  
  return(dataframe)
}
```

```{r}
elk_reg_id <- split(elk_regdata, elk_regdata$id)
```


```{r}
elk_reg_id2 <- lapply(elk_reg_id,
                            getMovementMetrics)
```


# Lavielle

The Lavielleâ€™s method identifies breaking points in a timeseries by using a moving window through the timeseries and a penalized contrast function which determines the optimal number of segments in the timeseries by minimizing the penalized contrast function (Lavielle 2005)

The method examine the variation in the mean and/or variance of a timeseries and identify the optimal number of break points, by fitting the mean, variance or both to the timeseries depending on the number of segments (K). As K increases, the fit increases. However, there should be a number of segments K after which adding more segments does not contributes significantly to improving the fit. The penalized contrast function adjust the trade-off between fit and K

```{r}
library(adehabitatLT)
```


```{r}
str(elk_reg_id2[["YL73"]])
```


```{r}
ggplot(data = elk_reg_id2[["YL73"]], aes(x = date, y = lat))+
  geom_path(color="darkgrey") +
  geom_point(size=0.5) +
  theme_classic() +
  xlab("Date") + ylab("Latitude")
```

decide a minimum number of relocations within a segment (Lmin), the maximum number of segments we want the function to try (Kmax) and if it should look at the difference in mean, variance, or both (mean, var, meanvar)

```{r}
elk_example_data <- elk_reg_id2[["YL73"]]

elk_lavielle_example <- lavielle(elk_example_data$lat, Lmin = 50, Kmax = 10, type = "mean")
```

```{r}
chooseseg(elk_lavielle_example)
```


```{r}
elk_lavielle_example_path <- findpath(elk_lavielle_example, 3)
```

```{r}

breakpoints <- unlist(elk_lavielle_example_path)

breakpoints
```

```{r}
breakpoints_df <- data.frame(Row_ID = breakpoints, segment = c(1,1,2,2,3,3))

elk_example_data$Row_ID <- cumsum(rep(1, nrow(elk_example_data)))

elk_example_data_lav <- merge(elk_example_data, breakpoints_df, by="Row_ID", all.x=TRUE)

elk_example_data_lav <- tidyr::fill(elk_example_data_lav, segment, .direction = 'down')

head(elk_example_data_lav)
```

# First Passage Time

The first passage time (FPT) is a parameter often used to describe the scale at which patterns occur in a trajectory. For a given scale r, it is defined as the time required by the animals to pass through a circle of radius r.

Fauchald & Tveraa (2003) proposed another use of the FPT. Instead of computing the mean of FPT, they propose the use of the variance of the log(FPT). This variance should be high for scales at which patterns occur in the trajectory (e.g. area restricted search). This method is often used to determine the scale at which an animal seaches for food

```{r}
library(mapview)
```

```{r}
elk_example_track <- elk_example_data |>
  st_as_sf(coords=c("lon","lat"), crs= 4326) |>
  st_union() |>
  st_cast("LINESTRING") 

mapview(elk_example_track)
```



transform the data into ltraj object

```{r}
elk_example_sp <- elk_example_data |>
  st_as_sf(coords=c("lon","lat"), crs= 4326) |> 
  st_transform(32611) |>
  st_cast("POINT") %>% as_Spatial()

elk_example_traj <- as.ltraj(coordinates(elk_example_sp), date=elk_example_data$date, id = elk_example_data$id)

summary(elk_example_traj)
```

```{r}
head(elk_example_traj[[1]])
```
```{r}
plot(elk_example_traj)
```


radii - numeric vector for the radii of the circles

units - time units of the results

```{r}
elk_example_fpt <- fpt(elk_example_traj, radii = seq(50, 10000), units="hours")
```

peak in variance at spatial scale of interest

```{r}
varlogfpt(elk_example_fpt, graph=TRUE)
```


```{r}
elk_example_fpt <- fpt(elk_example_traj, radii = 10000, units="hours")

plot(elk_example_fpt, scale = 9000, warn = FALSE)
```

```{r}

elk_example_data$FPT <- elk_example_fpt[[1]]$r1

ggplot() +
  geom_path(data = elk_example_data, aes(x = date, y = scale(FPT)), color="darkgrey", size = 1) +
  geom_path(data = elk_example_data, aes(x = date, y = scale(lat)), color ="orange", alpha = 0.6, size = 1) +
  geom_point(data = elk_example_data, aes(x = date, y = scale(FPT))) +
  theme_classic() +
  ylab("Scaled FPT (grey) vs Latitude (orange)")
```

# Behavioral Change Point Analysis

The "smoove" package allows for multiple continuous-time movement models (correlated velocity models or CVMs) to be fit to irregular tracking data to identify "modes" of behavior. Each model comes with it's own set of parameters and best models are determined using AIC/BIC and maximum likelihood. CVM model options include: Uncorrelated CVM (UCVM), Advective CVM (AVCM), Rotational CVM (RCVM), and Rotational-Advective CVM (RACVM). A single-change point can also be identified assuming just a UCVM process and sudden changes in the UCVM parameters, time scale, and root mean square speeds.

```{r eval=FALSE}
library(devtools)

install_github("EliGurarie/smoove")
```

```{r}
library(smoove)
```


```{r}
elk_utm <- elk_regdata |>
  st_as_sf(coords = c("lon","lat"), crs = 4326) |>
  st_transform(32611)

coords <- st_coordinates(elk_utm)

elk_regdata$X <- coords[,1]

elk_regdata$Y <- coords[,2]

elk_regdata$Z <- elk_regdata$X + 1i*elk_regdata$Y

elk_example <- elk_regdata |>
  dplyr::select(id, date, X, Y, Z) |>
  dplyr::filter(id=="YL73")

```

```{r}

with(elk_example, scan_track(x = X, y = Y, main = "YL73"))
```

specify window size (how long does behavior last?)

try: 200 days

takes awhile to run

```{r eval = FALSE}
elk_sweep <- with(elk_example, sweepRACVM(Z = Z, T = date, windowsize = 200, time.unit = "days", windowstep = 30, model = "RACVM", progress = TRUE))
```

parallel example

```{r}
library(doParallel)
```

```{r eval = FALSE}
cl <- parallel::makeCluster(parallel::detectCores())

doParallel::registerDoParallel(cl)

elk_sweep <- with(elk_example, sweepRACVM(Z = Z, T = date, windowsize = 200, time.unit = "days", windowstep = 30, model = "RACVM", progress = TRUE, .parallel = TRUE))
```

```{r include = FALSE}
#save(elk_sweep, file="./data/elk_behavioral_changepoint.rda")

load("./data/elk_behavioral_changepoint.rda")
```




colors represent the relative log-likelihood profile for a single window

looking for distinct peaks (significant change points) 

```{r}
plotWindowSweep(elk_sweep, main = "YL73")
```

Can specify the clusterwidth here- I used widths ranging from 1-6, based on warnings given with fitting the function for each id

I used all models as candidates (UCVM, ACVM, RCVM, RACVM)

I additionally used AIC to determine models, as BIC can be overly conservative

```{r}
elk_cp <- findCandidateChangePoints(windowsweep = elk_sweep, clusterwidth = 6) |>
  getCPtable(modelset = "all",criterion="AIC")
```

estimate phases

```{r}
elk_phases <- elk_cp |>
  estimatePhases()

elk_phases_summ <- summarizePhases(elk_phases)

```

```{r}
str(elk_phases_summ)
```


```{r}
elk_phases_data <- merge(elk_example, elk_phases_summ, all = TRUE, by.x = c("date"), by.y = c("end")) |> arrange(date) |>
  tidyr::fill(phase, start, model, eta, tau, rms, .direction = "updown")

str(elk_phases_data)
```


```{r}
ggplot(data = elk_phases_data, aes(x = date, y = Y, color = model))+
    geom_path(size=1.5)+
    xlab("Datetime")+ylab("Latitude")+
    theme_classic()
```

```{r}
ggplot(data = elk_phases_data, aes(x = date, y = Y, color = phase))+
    geom_path(size=1.5)+
    xlab("Datetime")+ylab("Latitude")+
    theme_classic()
```




# Hidden Markov Model

```{r}
library(momentuHMM)
```


```{r}
elk_hmm_prep <- prepData(elk_example, type = "UTM",
                                    coordNames = c("X","Y")) 

head(elk_hmm_prep)
```

set any step lengths with a value of 0 to 1 (can't have 0's)

```{r}
elk_hmm_prep$step[elk_hmm_prep$step == 0] <- 1
```

define priors and prior distributions

1 - state 1

2 - state 2

```{r}
stepMean0 <- c(m1 = 100, m2 = 4000)
stepSD0 <- c(sd1 = 50, sd2 = 1000)
angleCon0 <- c(rho1  = 0.1, rho2 = 0.8)
```

```{r}
stateNames <- c("resident","transit")
```

set distributions for variables (step lengths and turning angles)

set priors (mean and sd for steps, concentration for angle)

see ?dgamma and ?dwrpcauchy

```{r}
dist <- list(step = "gamma", angle = "wrpcauchy")
Par0 <- list(step=c(stepMean0, stepSD0), angle = c(angleCon0))
```

nbStates = number of states to identify

```{r}
elk_hmm_fit <- fitHMM(data = elk_hmm_prep, nbStates = 2, dist = dist, 
                      Par0 = Par0, stateNames = stateNames)

print(elk_hmm_fit)
```

viterbi formula to decode the transition probabilities for most likely states at each time point/location

```{r}
hmm_states <- viterbi(elk_hmm_fit)

str(hmm_states)
    
```
what does this code do?

```{r}
M <- elk_hmm_fit$mle$gamma

step <- elk_hmm_fit$mle$step

angle <- elk_hmm_fit$mle$angle[2,] 
```

what does this code do? proportion of locs in each state?

```{r}
probs <- c(s2 = M[1,2]/(M[1,2] + M[2,1]), 
              s1 = M[2,1]/(M[1,2] + M[2,1]))

probs
```

```{r}
elk_example$state <- hmm_states
```


```{r}

layout(cbind(c(1,1),2:3))
par(bty = "l", mar = c(2,2,2,2))

with(elk_example, {
  plot(X, Y, asp =1, col = c("orange","blue")[state], pch = 19, cex = 0.7)
  segments(X[-length(X)], Y[-length(Y)], 
           X[-1], Y[-1], col = c("orange","blue")[state[-length(state)]])
  plot(date, X, col = c("orange","blue")[state], pch = 19, cex = 0.7)
  segments(date[-length(X)], Y[-length(Y)], 
           date[-1], Y[-1], col = c("orange","blue")[state[-length(state)]])
  plot(date, Y, col = c("orange","blue")[state], pch = 19, cex = 0.7)
  segments(date[-length(X)], Y[-length(Y)], 
           date[-1], Y[-1], col = c("orange","blue")[state[-length(state)]])
})
```

```{r}
elk_example_sf <- elk_example |>
  st_as_sf(coords=c("X","Y"), crs= 32611) |>
  st_transform(4326) |>
  mutate(state = as.character(state))

elk_example_track <- elk_example_sf |>
  summarize(do_union=FALSE) |> 
  st_cast("LINESTRING")

mapview(elk_example_track, color="darkgrey") +
  mapview(elk_example_sf, zcol="state", col.regions=c("orange","blue"))
```

refit and 
add covariate (latitude)

```{r}
formula <- ~y

elk_hmm_fit2 <- fitHMM(data = elk_hmm_prep, nbStates = 2, dist = dist, 
                      Par0 = Par0, stateNames = stateNames, formula = formula)

print(elk_hmm_fit2)
```


```{r}
hmm_states <- viterbi(elk_hmm_fit2)

elk_example$state <- hmm_states
    
```



```{r}

layout(cbind(c(1,1),2:3))
par(bty = "l", mar = c(2,2,2,2))

with(elk_example, {
  plot(X, Y, asp =1, col = c("orange","blue")[state], pch = 19, cex = 0.7)
  segments(X[-length(X)], Y[-length(Y)], 
           X[-1], Y[-1], col = c("orange","blue")[state[-length(state)]])
  plot(date, X, col = c("orange","blue")[state], pch = 19, cex = 0.7)
  segments(date[-length(X)], Y[-length(Y)], 
           date[-1], Y[-1], col = c("orange","blue")[state[-length(state)]])
  plot(date, Y, col = c("orange","blue")[state], pch = 19, cex = 0.7)
  segments(date[-length(X)], Y[-length(Y)], 
           date[-1], Y[-1], col = c("orange","blue")[state[-length(state)]])
})
```

add a third state

```{r}
stepMean0 <- c(m1 = 100, m2 = 4000, m3 = 1000)
stepSD0 <- c(sd1 = 50, sd2 = 1000, sd3 = 500)
angleCon0 <- c(rho1  = 0.1, rho2 = 0.8, rho3 = 0.5)
```

```{r}
stateNames <- c("resident","transit", "other")
```

```{r}
dist <- list(step = "gamma", angle = "wrpcauchy")
Par0 <- list(step=c(stepMean0, stepSD0), angle = c(angleCon0))
```

```{r}
formula <- ~y

elk_hmm_fit3 <- fitHMM(data = elk_hmm_prep, nbStates = 3, dist = dist, 
                      Par0 = Par0, stateNames = stateNames, formula = formula)

```


```{r}
hmm_states <- viterbi(elk_hmm_fit3)

elk_example$state <- hmm_states
    
```



```{r}

layout(cbind(c(1,1),2:3))
par(bty = "l", mar = c(2,2,2,2))

with(elk_example, {
  plot(X, Y, asp =1, col = c("orange","blue","green")[state], pch = 19, cex = 0.7)
  segments(X[-length(X)], Y[-length(Y)], 
           X[-1], Y[-1], col = c("orange","blue", "green")[state[-length(state)]])
  plot(date, X, col = c("orange","blue", "green")[state], pch = 19, cex = 0.7)
  segments(date[-length(X)], Y[-length(Y)], 
           date[-1], Y[-1], col = c("orange","blue", "green")[state[-length(state)]])
  plot(date, Y, col = c("orange","blue", "green")[state], pch = 19, cex = 0.7)
  segments(date[-length(X)], Y[-length(Y)], 
           date[-1], Y[-1], col = c("orange","blue", "green")[state[-length(state)]])
})
```

```{r}
elk_example_sf <- elk_example |>
  st_as_sf(coords=c("X","Y"), crs= 32611) |>
  st_transform(4326) |>
  mutate(state = as.character(state))

elk_example_track <- elk_example_sf |>
  summarize(do_union=FALSE) |> 
  st_cast("LINESTRING")

mapview(elk_example_track, color="darkgrey") +
  mapview(elk_example_sf, zcol="state", col.regions=c("orange","blue", "green"))
```

