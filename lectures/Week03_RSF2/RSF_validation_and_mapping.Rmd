---
title: "RSF: Cross-Validation and Mapping"
author: "Riley & Nate & Elie"
date: "2023-09-20"
output: 
  html_document:
    toc: true
    toc_float: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = FALSE)
```

## Data

American black ducks (*Anas rubripes*) and mallards (*Anas platyrhynchos*) overlap in their food habits, and have to acquire enough carbohydrates during the winter period to survive and complete their spring migration. As the eastern mallard population continues to climb, it is important to understand the degree of habitat overlap to inform future management decisions. 

This dataset consists of 20 ducks (17 black ducks, and 3 mallards) on eastern Long Island monitored using GPS backpack transmitters from February to the end of March in 2022. The data was collected by Riley Stedman as part of her master's project through SUNY ESF in partnership with the Long Island Waterfowl Heritage Group and Delta Waterfowl. 

# Goals

The goal is to perform cross-validation as per Boyce et al. 2002 and mapping as per recommendations of Morris et al. 2016. Objectives include: (1) identify which habitats are being selected for, (2) does distance to shore has an effect on selection, and (3) are there any differences in selection depending on the time of day.

# 1. Load data

```{r, message = FALSE, warning = FALSE}
require(sf)
require(terra)
```

Rasters are (1) landcover and (2) distance to coastline

```{r habitatplot}
require(terra)
duck.landcover <- rast("data/Landcover.tif")
dtoshore <- rast("data/DtoShore.tif")
habitat <- c(duck.landcover,dtoshore)
plot(habitat)
```

RSF data has been agonizingly prepped by Riley & Nate & Elie.

```{r}
load("data/ducks_rsf.rda")
```

Object is called:

```{r}
ducks.rsf %>% head
```

As you can see, the object contains the landcover class index (landcover), the landcover name (landcover.name) which will be more useful for analysis, the date and time in EST (datetime), longitude (X) and latitude (Y), distance to shore (dtoshore), and a "Used" column set to TRUE to indicate these points as the observed data (used) or FALSE to indicate the null (available) set.

The null set consists of 30,000 points (~3x as many points as the used set) inside Suffolk county, which is here:

```{r}
load("data/Suffolk.rda")
```

```{r UsedVAvailable, fig.width = 10, fig.height = 4}
plot(st_geometry(Suffolk))
with(ducks.rsf[ducks.rsf$Used == 0,],
     points(X,Y, pch = 19, cex = 0.1, col = rgb(0,0,0,.1)))
with(ducks.rsf[ducks.rsf$Used == 1,], 
     points(X,Y, pch = 19, cex = 0.3, col = rgb(1,0,0,.5)))
```

The map shows the null set in black dots, and used set in red.

# 2. Fit an RSF

We use the function 'glm' to fit the RSF model using landcover and distance to shore as covariates.

```{r}
duck.fit <- glm(Used ~ landcover.name + 
                  dtoshore, family = "binomial", data = ducks.rsf)

summary(duck.fit)
```

What is the reference class?  It's the first level of the categorical covariate:

```{r}
levels(ducks.rsf$landcover.name)
```

So "Barren Land".

You could change it using the function below, but we'll leave it as is for this 

```{r}
#ducks.rsf$landcover.name <- relevel(ducks.rsf$landcover.name, "Open Water")
```

**All the coefficients for a categorical covariate are RELATIVE to that reference class!**

```{r}
require(broom)
tidy(duck.fit)
require(coefplot)
coefplot(duck.fit, sort = "magnitude")
```



# 3. Cross-validation

The first step to cross-validation is to split the data up into a test set & training set. Here, the test set is 
1/5th of the data, and the training set is 4/5th.

```{r}
# 5-fold validation

n <- nrow(ducks.rsf)
k <- 5

training <- sample(1:n)[1:(round(n*(1-1/k)))]
test <- (1:n)[! (1:n) %in% training]

ducks_training <- ducks.rsf[training,]
ducks_test <- ducks.rsf[test,]
```

We then fit the model with the training set...

```{r}
duck.fit.training <- glm(Used ~ landcover.name + 
                  dtoshore, family = "binomial", data = ducks_training)
```

...and use it to predict the test (out of sample) set:

```{r}
nbins <- 10
duck.predict.test  <- predict(duck.fit.training, newdata = ducks_test)
predict.quantiles <- quantile(duck.predict.test, seq(0,1, length = nbins+1), na.rm = TRUE)

predict.matrix <- as.matrix(table(ducks_test$Used, cut(duck.predict.test, predict.quantiles)))

p.present <- apply(predict.matrix, 2, function(x) x[2]/sum(x))
cv.score <- cor(1:nbins, p.present, method = "spearman")
```

High cross-validation score!

```{r}
cv.score
```

A function in the `[IndRSA](https://github.com/BastilleRousseau/IndRSA)` package does all of these things at once. This package is not on CRAN, and needs to be installed via:

```{r, eval = FALSE}
#library(devtools)
#install_github("BastilleRousseau/IndRSA")
```


```{r}
#require(IndRSA)
#duck_kfold <- kfoldRSF(duck.fit)
#duck_kfold
```


# 4. Mapping

To map we need to *predict* across our rasters. 

## Fit a model

The model has to be fit using "landcover" (not landcover.name as above), since the covariates need to be factors 
in this case
```{r}
duck.fit <- glm(Used ~ factor(landcover) + 
                  dtoshore, family = "binomial", data = ducks.rsf)
```

## Create a prediction data frame from raster

Now we need to make a data frame of ALL the raster values in the covariate stack.

```{r}
allcovars.df <- terra::as.data.frame(habitat, na.rm = FALSE)
```

## Predict model for new data frame

Then we "predict" the model over this stack... except this will give an error. 

```{r, eval = FALSE}
duck.predict.values <- predict(duck.fit, newdata = allcovars.df)
```

```
Error in model.frame.default(Terms, newdata, na.action = na.action, xlev = object$xlevels) : 
  factor factor(landcover) has new levels 0
```

Why? Because there are "zeros" in the landcover data that are not in the duck data. Therefore, we need to remove them from the prediction data frame. 

```{r}
allcovars.df$landcover[allcovars.df$landcover == 0] <- NA
duck.predict.values <- predict(duck.fit, newdata = allcovars.df)
```

## Create new raster of predictions

Prep a raster, identical in structure to the original habitat rasters:

```{r}
duck.predict.raster <- habitat[[1]]
```

Fill that raster with the prediction values:

```{r}
values(duck.predict.raster) <- duck.predict.values
```

## Simple map

```{r}
plot(duck.predict.raster, main = "predictor")
```
```{r}
require(rasterVis)
levelplot(duck.predict.raster)
```

Or back-transform to probabilities?

```{r}
levelplot(exp(duck.predict.raster)/(1+exp(duck.predict.raster)), main = "probabilities?")
```

Or w(x) rsf function?

```{r}
levelplot(exp(duck.predict.raster), main = "w(x)")
```

These are NOT very helpful! So let's map using the recommendations of Morris et al. 2016

## Equal area bins

This is the method Morris likes best of all. Here we'll break the data into 10 equal area bins, in which each "level" will contain the same number of raster cells. 

Key functions here are:  `cut` and `quantile`

```{r}
n.bins <- 10
breaks <- quantile(duck.predict.values, seq(0,1,length = n.bins + 1), na.rm = TRUE)
duck.predict.binned <- cut(duck.predict.values, breaks)

duck.predict.raster.binned <- duck.predict.raster
values(duck.predict.raster.binned) <- duck.predict.binned
```

Here's a plot using my favorite high-contrast color palette:

```{r}
require(gplots)
plot(duck.predict.raster.binned, col = rich.colors(n.bins))
```

We can see that the dark blue are areas that are avoided, and the red are the most selected for. 

## Bundling things into a function

This can be super useful:

```{r}
getBinnedRaster  <- function(duck.model, n.bins){
  
  duck.predict.values <- predict(duck.model, newdata = allcovars.df)
  breaks <- quantile(duck.predict.values, seq(0,1,length = n.bins + 1), na.rm = TRUE)
  duck.predict.binned <- cut(duck.predict.values, breaks)
  duck.predict.raster.binned <- duck.predict.raster
  
  values(duck.predict.raster.binned) <- duck.predict.binned
  return(duck.predict.raster.binned)
}
```

Test function on what we made:

```{r}
r1 <- getBinnedRaster(duck.fit, 10)
plot(r1,  col = rich.colors(10))
```

Which gives us the same plot as before, woohoo!

Let's try a different model, e.g. with second order distance to shore:

```{r}
duck.fit2 <- glm(Used ~ factor(landcover) + dtoshore + I(dtoshore^2), 
                 family = "binomial", data = ducks.rsf)
r2 <- getBinnedRaster(duck.fit2, 10)
plot(r2,  col = rich.colors(10))
```

Not much change there.

Let's try another model, where we compare dawn and dusk (the times when ducks are most likely to make feeding trips).

```{r}
require(lubridate)

duck.fit.dawn <- glm(Used ~ factor(landcover) + dtoshore, 
                 family = "binomial", data = ducks.rsf %>% 
                   subset(hour(datetime) > 5 & hour(datetime) < 8 | 
                    Used == FALSE))

duck.fit.dusk <- glm(Used ~ factor(landcover) + dtoshore, 
                 family = "binomial", data = ducks.rsf %>% 
                   subset(hour(datetime) > 18 | hour(datetime) < 21 | 
                    Used == FALSE))

r.dawn <- getBinnedRaster(duck.fit.midday, 10)
r.dusk <- getBinnedRaster(duck.fit.midnight, 10)

```

```{r DayVNight}
par(mfrow = c(1,2))
plot(r.midday,  col = rich.colors(10), main = "dawn")
plot(r.midnight,  col = rich.colors(10), main = "dusk")
```

The difference is subtle, but we can also compare their coefficients to see the difference. 

```{r}
glm(Used ~ landcover.name + dtoshore, 
                 family = "binomial", data = ducks.rsf %>% 
                   subset(hour(datetime) > 5 & hour(datetime) < 8 | Used == FALSE)) %>% 
  coefplot(sort = "magnitude", title = "dawn")

glm(Used ~ landcover.name + dtoshore, 
                 family = "binomial", data = ducks.rsf %>% 
                   subset(hour(datetime) > 18 | hour(datetime) < 21 | Used == FALSE))%>% 
  coefplot(sort = "magnitude", title = "dusk")

```

There seems to be a slightly greater selection for cultivated crops at dusk than there is at dawn. This aligns nicely with field data, which shows a greater abundance of ducks in corn fields around dusk compared to dawn.  


