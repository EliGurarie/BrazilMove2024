---
title: "Short Lecture on Complex Numbers"
subtitle: "Brazil Move 2024"
author: "Elie Gurarie"
output: 
  xaringan::moon_reader:
    css: [default, default-fonts, mycss.css]
    nature:
      highlightStyle: github
      countIncrementalSlides: false
      highlightLines: true
      titleSlideClass: ["center"]
      ratio: '16:9'
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, 
                      fig.height=4, fig.width = 6,
                      cache = TRUE, warning = FALSE, las = 1, dpi = 200)
#output: html_document
```

```{r colsFunction, eval = FALSE}
xaringan::inf_mr()
```


```{r echo = FALSE}
pcks <- c("fields", "gplots", "scales")
a <- sapply(pcks, require, character = TRUE)
```


.pull-left[

## Why complex numbers? 

> The  **most efficient way** to deal with 2D vectors, both in .red[math] and in .blue[R code]. 

> They are simple!
]

--

.pull-right[

## What is a complex number? 

$$ Z = X + iY $$

- $X$ is the **real** part.  
- $Y$ is the **imaginary** part.

The same number can be written:

$$ Z = R \exp(i \theta) $$
- $R$ is the length of the vector: the **modulus**
- $\theta$ is the orientation of the vector: the **argument**
]

---


.pull-left-30[
## An example

```{r makeZ, tidy=FALSE, echo = TRUE}
X <- c(3,4,-2)
Y <- c(0,3,2)
Z <- X + 1i*Y
Z
```
Alternatively: 
```{r}
Z <- complex(re = X, im=Y)
```
]

.pull-right-70[

```{r plotZ, dpi=300, echo=-1}
par(bty="l", cex.lab=1)
plot(Z, pch=19, col=1:3, asp=1)
arrows(rep(0,length(Z)), rep(0,length(Z)), Re(Z), Im(Z), lwd=2, col=1:3)
```
> *Note: ALWAYS use `asp=1` - "aspect ratio = 1:1" - when plotting (properly projected) movement data!*
]

---


## Obtaining summary statistics

Obtain lengths of vectors - **modulus** `Mod()`:
```{r echo = TRUE}
Mod(Z)
```

Obtain orientation of vectors - **argument** `Arg()`
```{r}
Arg(Z)
```
Note, the orientations are in radians, i.e. range from $0$ to $2\pi$ going **counter-clockwise** from the $x$-axis.  Compass directions go from 0 to 360  **clockwise**, so, to convert:
```{r}
90-(Arg(Z)*180)/pi
```


---

## Lets play with a trajectory

Quick code for a correlated random walk:
<center>
```{r SRW, tidy=FALSE}
X <- cumsum(arima.sim(n=100, model=list(ar=.7)))
Y <- cumsum(arima.sim(n=100, model=list(ar=.7)))
Z <- X + 1i*Y
plot(Z, type="o", asp=1)
```

---

## Instant summary statistics of a trajectory:

The average location
```{r}
mean(Z)
```

The step vectors:

.center[
```{r}
dZ <- diff(Z)
plot(dZ, asp=1, type="n")
arrows(rep(0, length(dZ)), rep(0, length(dZ)), Re(dZ), Im(dZ), col=rgb(0,0,0,.5), lwd=2, length=0.1)
```
]


---


## Distribution of step lengths

.center[
```{r}
S <- Mod(dZ)
summary(S)
hist(S, col="grey", bor="darkgrey", freq=FALSE)
lines(density(S), col=2, lwd=2)
```
]



---


## What about angles?

.pull-left[
- The absolute orientations:

```{r, echo=-1}
par(bty="l", xpd=TRUE)
Phi <- Arg(dZ)
hist(Phi, col="grey", bor="darkgrey", freq=FALSE, breaks=seq(-pi,pi,pi/3))
```
]

.pull-right[

- Turning angles
```{r, echo=-1}
par(bty="l", xpd=TRUE)
Theta <- diff(Phi)
hist(Theta, col="grey", bor="darkgrey", freq=FALSE)
```

**<font color="blue"> QUESTION: What is a problem with this histogram?</font>**
]

---

## Circular statistics

Angles are a **wrapped continuous variable**, i.e. $180^o > 0^o = 360^o < 180^o$. The best way to visualize the distribution of wrapped variables is with **Rose-Diagrams**.  An R package that deals with circular data is `circular`. 

.center[
```{r, message=FALSE, warning=FALSE, echo=-1}
par(mfrow=c(1,2))
require(circular)
Theta <- as.circular(Theta)
Phi <- as.circular(Phi)
rose.diag(Phi, bins=16, col="grey", prop=2, main=expression(Phi))
rose.diag(Theta, bins=16, col="grey", prop=2, main=expression(Theta))
```
]

---

## LAB EXERCISE

.large[
> 1. Load movement data of choice!
> 2. Convert the locations to a complex variable Z.
> 3. Obtain a vector of time stamps T, draw a histogram of the time intervals. Then, ignore those differences. 
> 4. Obtain, summarize and illustrate:
>
> -  the step lengths 
> -  the absolute orientation
> -  the turning angles
]

---

## Complex manipulations (are easy)

.pull-left[
Addition and subtraction of vectors: 

$$ Z_1 = X_1 + i Y_1; Z_2 = X_2 + i Y_2$$
$$ Z_1 + Z_2 = (X_1 + X_2) + i(Y_1 + Y_2)$$

Useful, e.g., for shifting locations:

```{r, echo=-1}
par(xpd=FALSE, bty="l")
plot(Z, asp=1, type="l", col="darkgrey", xlim=c(-2,2)*max(Mod(Z)))
lines(Z - mean(Z), col=2, lwd=2)
lines(Z + Z[length(Z)], col=3, lwd=2)
```
]

---

## Complex manipulations (are easy)

Multiplication of complex vectors
$$ Z_1 = R_1 \exp(i \theta_1); Z_2 = R_2 \exp(i \theta_2)$$
$$ Z_1 Z_2 = R_1 R_2 \exp(i (\theta_1 + \theta_2))$$

If $\text{Mod}(Z_2) = 1$, multiplications *rotates* by $\text{Arg}(Z_2)$
.center[

```{r, echo=-1}
par(xpd=TRUE, bty="l")
Rot1 <- complex(mod=1, arg=pi/4)
Rot2 <- complex(mod=1, arg=-pi/4)
plot(Z, asp=1, type="l", col="darkgrey", lwd=3)
lines(Z*Rot1, col=2, lwd=2)
lines(Z*Rot2, col=3, lwd=2)
```
]

---

## A colorful loop:

.pull-left[
```{r, eval=FALSE}
require(gplots)
plot(Z, asp=1, type="n", xlim=c(-1,1)*max(Mod(Z)), ylim=c(-1,1)*max(Mod(Z)))
cols <- rich.colors(1000,alpha=0.1)
thetas <- seq(0,2*pi,length=100)
for(i in 1:1000)
  lines(Z*complex(mod=1, arg=thetas[i]), col=cols[i], lwd=4)
```
]

***

.pull=right[
```{r SillyRainbow, fig.height=7, fig.width=7, echo=FALSE}
require(gplots)
plot(Z, asp=1, type="n", xlim=c(-1,1)*max(Mod(Z)), ylim=c(-1,1)*max(Mod(Z)))
cols <- rich.colors(1000,alpha=0.1)
thetas <- seq(0,2*pi,length=1000)
for(i in 1:1000)
  lines(Z*complex(mod=1, arg=thetas[i]), col=cols[i], lwd=4)
```
</center>



I know you're thinking ...
========================================================
incremental: true
<br>
<br>

<center>
>*"Thanks for teaching me how to make a weird swirling rainbow thing ... but why in the world would I want to shift and rotate my precious, precious data, which was just perfect the way it was?*

<br>
<br>
<br>

My response: **<font color="darkred"> Null Sets for Pseudo Absences! </font>**
</center>



Example with Finnish Wolves
========================================================
![](./images/Susi.png)

In-depth summer predation study, questions related to habitat use 
 * landscape type  - forest/bog/field
 * linear elements  - roads/rivers/power lines, etc.

***

![](./images/Fig5.png)



Defining Null Sets
========================================================
incremental: true

1. Obtain all the steps and turning angles
2. Rotate them by the orientation of the last step ($Arg(Z_1-Z_0)$)
3. Add the rotated steps to the last step ($Z_1$)

***

<center>
![](./images/RII.png)
<center>




Calculating Null Sets in R
========================================================
transition: none
<font color="red">
1. Obtain all the steps and turning angles <br>
2. Rotate them by the orientation of the last step ($Arg(Z_1-Z_0)$)
</font>

```{r}
Z <- Z[1:10]
n <- length(Z)
S <- Mod(diff(Z))
Phi <- Arg(diff(Z))
Theta <- diff(Phi)
RelSteps <- complex(mod = S[-1], arg=Theta)

Z0 <- Z[-((n-1):n)]
Z1 <- Z[-c(1,n)]
Z2 <- Z[-(1:2)]

Rotate <- complex(mod = 1, arg=Arg(Z1-Z0))
```

***


```{r, echo=-1}
par(bty="l", axis=FALSE)
plot(c(0,RelSteps), asp=1, xlab="x", ylab="y", pch=19)
arrows(rep(0,n-2), rep(0, n-2), Re(RelSteps), Im(RelSteps), col="darkgrey")
```
> Note: in practice (i.e. with tons of data), it is sufficient to randomly sample some smaller number (e.g. 30) null steps at each location.


Fuzzy catterpillar plot
========================================================

<font color="red">
3. Add the rotated steps to the last step
</font>

```{r, eval=TRUE}
Z.null <- matrix(0, ncol=n-2, nrow=n-2)
for(i in 1:length(Z1))
  Z.null[i,] <- Z1[i] + RelSteps * Rotate[i]
```

<font color="red">
4. Make the fuzzy catterpillar plot
</font>
```{r eval = FALSE}
palette(rich.colors(10))
plot(Z, type="o", col=1:10, pch=19, asp=1)
for(i in 1:nrow(Z.null))
  segments(rep(Re(Z1[i]), n-2), rep(Im(Z1[i]), n-2), s
           Re(Z.null[i,]), Im(Z.null[i,]), col=i+1)
```

***

```{r, echo=FALSE, fig.height=8}
par(bty="l", axes=FALSE)
palette(rich.colors(10))

plot(Z, type="o", col=1:10, pch=19, asp=1)
for(i in 1:nrow(Z.null))
  segments(rep(Re(Z1[i]), n-2), rep(Im(Z1[i]), n-2), 
           Re(Z.null[i,]), Im(Z.null[i,]), col=i+1)
```



Using the null-set
========================================================
incremental: true
left: 40% 

The use of the null set is a way to test a narrower null hypothesis that accounts for auto correlation in the data.  

The places the animal COULD HAVE but DID NOT go to are *pseudo-absences*, against which you can fit, e.g., logistic regression models (aka **Step-selection functions**).

Or just be simple/lazy (like us) and compare observed locations with Chi-squared tests:

***

![](./images/SusiResults.png)
![](./images/SusiResults2.png)




EXERCISE: Create a fuzzy-catterpillar plot!
========================================================
right: 30%

Use (a portion) of the data you analyzed before. 
<small>
```{r, eval=FALSE}
# get pieces
n <- length(Z)
S <- Mod(diff(Z))
Phi <- Arg(diff(Z))
Theta <- diff(Phi)
RelSteps <- complex(mod = S[-1], arg=Theta)

# calculate null set
Z0 <- Z[-((n-1):n)]
Z1 <- Z[-c(1,n)]
Z.null <- matrix(0, ncol=n-2, nrow=n-2)
for(i in 1:length(Z1))
  Z.null[i,] <- Z1[i] + sample(max(length(RelSteps),30)) * Rotate[i]

# plot
plot(Z, type="o", col=1:10, pch=19, asp=1)
for(i in 1:nrow(Z.null))
  segments(rep(Re(Z1[i]), n-2), rep(Im(Z1[i]), n-2), 
           Re(Z.null[i,]), Im(Z.null[i,]), col=i+1)
```
</small>

***

![](./images/PolarBearFuzzyCatterpillar.png)
Fuzzy Polar Bear Catterpillar!

